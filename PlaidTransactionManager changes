package com.app.budgetbuddy.workbench.plaid;

import com.app.budgetbuddy.domain.PlaidTransaction;
import com.app.budgetbuddy.domain.RecurringTransactionDTO;
import com.app.budgetbuddy.domain.Transaction;
import com.app.budgetbuddy.entities.PlaidLinkEntity;
import com.app.budgetbuddy.entities.RecurringTransactionEntity;
import com.app.budgetbuddy.entities.TransactionsEntity;
import com.app.budgetbuddy.entities.UserEntity;
import com.app.budgetbuddy.exceptions.*;
import com.app.budgetbuddy.repositories.AccountRepository;
import com.app.budgetbuddy.services.PlaidLinkService;
import com.app.budgetbuddy.services.RecurringTransactionService;
import com.app.budgetbuddy.services.TransactionService;
import com.app.budgetbuddy.services.UserService;
import com.app.budgetbuddy.workbench.converter.RecurringTransactionConverter;
import com.app.budgetbuddy.workbench.converter.TransactionConverter;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.plaid.client.model.*;
import com.plaid.client.request.PlaidApi;
import jakarta.transaction.InvalidTransactionException;
import lombok.extern.slf4j.Slf4j;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.couchbase.CouchbaseProperties.Io;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import retrofit2.Call;
import retrofit2.Response;

import java.io.IOException;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;

@Service
@Slf4j
public class PlaidTransactionManager extends AbstractPlaidManager
{
    private final RecurringTransactionConverter recurringTransactionConverter;
    private final RecurringTransactionService recurringTransactionService;
    private final UserService userService;
    private final String clientId = "BudgetBuddy";
    private final int MAX_ATTEMPTS = 5;

    @Autowired
    public PlaidTransactionManager(PlaidLinkService plaidLinkService, PlaidApi plaidApi,
                                   RecurringTransactionConverter recurringTransactionConverter,
                                   RecurringTransactionService recurringTransactionService,
                                   UserService userService)
    {
        super(plaidLinkService, plaidApi);
        this.recurringTransactionConverter = recurringTransactionConverter;
        this.recurringTransactionService = recurringTransactionService;
        this.userService = userService;
    }

    public TransactionsGetRequest createTransactionRequest(String accessToken, LocalDate startDate, LocalDate endDate)
    {
       try
       {
          if(accessToken.isEmpty() || accessToken == null)
          {
             throw new InvalidAccessTokenException("Invalid access token");
          }
          return new TransactionsGetRequest()
            .accessToken(accessToken)
            .clientId("BudgetBuddy")
            .startDate(startDate)
            .endDate(endDate);
       }catch(InvalidAccessTokenException ex){
           log.error("There was an error creating the transaction request: ", ex.getMessage());
           throw ex;
       }
    }

    @Async("taskExecutor")
    public CompletableFuture<TransactionsGetResponse> getAsyncTransactionsResponse(Long userId, LocalDate startDate, LocalDate endDate) throws IOException 
    {
        PlaidLinkEntity plaidLink = findPlaidLinkByUserId(userId);
        String accessToken = plaidLink.getAccessToken();
        TransactionsGetRequest transactionGetRequest = createTransactionRequest(accessToken, startDate, endDate);
        Call<TransactionsGetResponse> transactionsGetResponseCall = plaidApi.transactionsGet(transactionGetRequest);
        Response<TransactionsGetResponse> transactionResponse = transactionsGetResponseCall.execute();
        if(transactionResponse.isSuccessful())
        {
            return CompletableFuture.completedFuture(transactionResponse.body());
        }
        else
        {
            int attempts = 0;
            Response<TransactionsGetResponse> responseRetry = null;
            while(attempts < MAX_ATTEMPTS)
            {
                try
                {
                    Call<TransactionsGetResponse> transactionGetResponseCall = plaidApi.transactionsGet(transactionGetRequest);
                    responseRetry = transactionGetResponseCall.execute();
                    if(responseRetry.isSuccessful())
                    {
                        return CompletableFuture.completedFuture(responseRetry.body());
                    }
                    else
                    {
                        attempts++;
                        if(attempts == MAX_ATTEMPTS)
                        {
                            log.info("MAX Attempts have been reached...Terminating call to plaid...");
                            break;
                        }
                        showPlaidResponseErrors(responseRetry, MAX_ATTEMPTS);
                    }
                    return CompletableFuture.completedFuture(null);
                }catch(IOException e){
                    log.error("There was an error fetching the plaid transactions from transactions get call: ", e.getMessage());
                    return CompletableFuture.failedFuture(e);
                }
            }
            return CompletableFuture.completedFuture(null);
        }
    }

    private void showPlaidResponseErrors(Response<TransactionsGetResponse> transactionsGetResponse, int attempts) throws IOException
    {
        if(transactionsGetResponse.errorBody() == null)
        {
            log.error("No Transaction Get Response found");
        }
        try
        {
            String errorBody = transactionsGetResponse.errorBody().string();
            JsonObject jsonError = JsonParser.parseString(errorBody).getAsJsonObject();
            String errorType = jsonError.has("error_type") ? jsonError.get("error_type").getAsString() : "Unknown";
            String errorCode = jsonError.has("error_code") ? jsonError.get("error_code").getAsString() : "Unknown";
            String errorMessage = jsonError.has("error_message") ? jsonError.get("error_message").getAsString() : "No Error Message";
            if("PRODUCT_NOT_READY".equals(errorCode))
            {
                log.info("Product Not Ready, implementing backoff strategy...");
                long delay = Math.min(5000 * (long) Math.pow(2, attempts - 1), 300000);
                Thread.sleep(delay);
            }
            log.error("Plaid API Error - Type: {}, Code: {}, Message: {}", errorType, errorCode, errorMessage);
            if(jsonError.has("display_message"))
            {
                String displayMessage = jsonError.get("display_message").getAsString();
                log.error("Display Message: {}", displayMessage);
            }
        }catch(InterruptedException e){
            log.error("The response was interrupted: ", e.getMessage());
            return;
        }catch(IOException ex){
            log.error("There was an error while fetching the transaction response errors: ", ex.getMessage());
            return;
        }
    }

    private TransactionsRecurringGetRequest createRecurringTransactionRequest(String accessToken, String clientId)
    {
        if(accessToken.isEmpty())
        {
            throw new InvalidAccessTokenException("No Access token was provided");
        }
        try
        {
            return new TransactionsRecurringGetRequest()
                .accessToken(accessToken)
                .clientId(clientId);
        }catch(InvalidAccessTokenException e){
            log.error("There was an error creating the recurring transaction request: ", e.getMessage());
            throw e;
        }
    }

    @Async("taskExecutor")
    public CompletableFuture<TransactionsRecurringGetResponse> getAsyncRecurringResponse(Long userId) throws IOException 
    {
        Optional<UserEntity> userEntityOptional = userService.findById(userId);
        if(userEntityOptional.isEmpty())
        {
            log.info("No user found with userId {}. Unable to fetch recurring transactions");
            return CompletableFuture.completedFuture(null);
        }
        try
        {
            // Fetch the Access Token from the user's plaid link
            PlaidLinkEntity plaidLinkEntity = findPlaidLinkByUserId(userId);
            String accessToken = plaidLinkEntity.getAccessToken();
            
            TransactionsRecurringGetRequest request = createRecurringTransactionRequest(accessToken, clientId);
            Call<TransactionsRecurringGetResponse> transactionsRecurringCall = plaidApi.transactionsRecurringGet(request);
            Response<TransactionsRecurringGetResponse> transactionRecurringResponse = transactionsRecurringCall.execute();
            if(transactionRecurringResponse.isSuccessful())
            {
                TransactionsRecurringGetResponse rBody = transactionRecurringResponse.body();
                return CompletableFuture.completedFuture(rBody);
            }
            else
            {
                int attempts = 0;
                Response<TransactionsRecurringGetResponse> retryResponse = null;
                while(attempts < MAX_ATTEMPTS)
                {
                    Call<TransactionsRecurringGetResponse> responseCall = plaidApi.transactionsRecurringGet(request);
                    retryResponse = responseCall.execute();
                    if(retryResponse.isSuccessful())
                    {
                        TransactionsRecurringGetResponse responseBody = retryResponse.body();
                        return CompletableFuture.completedFuture(responseBody);
                    }
                    else
                    {
                        attempts++;
                        if(attempts == MAX_ATTEMPTS)
                        {
                            log.info("MAX Attempts Reached.");
                            break;
                        }
                    }
                }
                return CompletableFuture.completedFuture(null);
            }

        }catch(IOException e){ 
            log.error("There was an error fetching the recurring transaction response from the plaid server: ", e.getMessage());
            return CompletableFuture.failedFuture(e);
        }
    }

    public List<RecurringTransactionEntity> saveRecurringTransactions(final List<RecurringTransactionDTO> recurringTransactions) throws IOException
    {
        if(recurringTransactions.isEmpty() || recurringTransactions == null)
        {
            return Collections.emptyList();
        }
        List<RecurringTransactionEntity> recurringTransactionEntities = new ArrayList<>();
        try
        {
            recurringTransactionEntities = recurringTransactions.stream()
                .map(recurringTransaction -> {
                    return recurringTransactionConverter.convert(recurringTransaction);
                })
                .distinct()
                .toList();
                if(recurringTransactionEntities.isEmpty() || recurringTransactionEntities == null)
                {
                    log.info("No Recurring Transactions were converted to entities.");
                    return Collections.emptyList();
                }
                
                recurringTransactionEntities.forEach(e -> {
                    recurringTransactionService.save(e);
                });
        }catch(DataException e){
            log.error("There was an error saving the recurring transactions to the database: ", e.getMessage());
            return Collections.emptyList();
        }

        return Collections.emptyList();
    }

    private TransactionsRefreshRequest createTransactionRefreshRequest(String accessToken)
    {
        if(accessToken.isEmpty() || accessToken == null)
        {
            throw new InvalidAccessTokenException("Invalid Access Token...");
        }
        try
        {
            return new TransactionsRefreshRequest()
                .accessToken(accessToken);
        }catch(InvalidAccessTokenException e){
            log.error("There was an error creating the transaction refresh request: ", e.getMessage());
            throw e;
        }
    }

    private TransactionsSyncRequest createSyncRequest(String accessToken, String cursor, TransactionsSyncRequestOptions options){
        return new TransactionsSyncRequest()
                .accessToken(accessToken)
                .cursor(cursor)
                .options(options);
    }

    public TransactionsSyncResponse syncTransactionsForUser(final String accessToken, final String cursor, final Long userId) throws IOException
    {
//        TransactionsSyncRequest transactionsSyncRequest = new TransactionsSyncRequest()
//                .accessToken(accessToken)
//                .count(500)
//                .cursor(cursor);
//        try
//        {
//            Call<TransactionsSyncResponse> transactionsSyncResponseCall = plaidApi.transactionsSync(transactionsSyncRequest);
//            Response<TransactionsSyncResponse> response = transactionsSyncResponseCall.execute();
//            if(response.isSuccessful() && response.body() != null)
//            {
//                return response.body();
//            }
//            else
//            {
//                throw new IOException("Failed to sync transactions for user ID " + userId);
//            }
//        }catch(IOException e){
//            log.error("There was an error syncing the transactions for userId {}", userId);
//            throw e;
//        }
        return null;
    }

    public TransactionsSyncResponse syncTransactionsForUser(final Long userId, final String cursor) throws IOException
    {
//        Optional<PlaidLinkEntity> plaidLinkEntityOptional = plaidLinkService.findPlaidLinkByUserID(userId);
//        if(plaidLinkEntityOptional.isEmpty())
//        {
//            throw new PlaidLinkException("Plaid link not found");
//        }
//        PlaidLinkEntity plaidLinkEntity = plaidLinkEntityOptional.get();
//        String accessToken = getPlaidAccessToken(plaidLinkEntity);
//        TransactionsSyncRequest transactionsSyncRequest = new TransactionsSyncRequest()
//                .accessToken(accessToken)
//                .count(500)
//                .cursor(cursor);
//        Call<TransactionsSyncResponse> transactionsSyncResponseCall = plaidApi.transactionsSync(transactionsSyncRequest);
//        Response<TransactionsSyncResponse> response = transactionsSyncResponseCall.execute();
//        if(response.isSuccessful() && response.body() != null)
//        {
//            return response.body();
//        }
//        else
//        {
//            throw new IOException("Failed to sync transactions for user ID " + userId);
//        }
        return null;
    }
    
    public List<TransactionsEntity> saveTransactionsToDatabase(final List<PlaidTransaction> transactionList)
    {
        List<TransactionsEntity> transactionsEntities = new ArrayList<>();
        if(transactionList.isEmpty())
        {
            throw new TransactionsNotFoundException("Transactions not found.");
        }
        for(PlaidTransaction transaction : transactionList)
        {
            if(transaction != null)
            {
                TransactionsEntity transactionsEntity = transactionConverter.convert(transaction);
                validateTransactionParameterForNulls(transactionsEntity);
                transactionService.save(transactionsEntity);
                transactionsEntities.add(transactionsEntity);
            }
        }
        return transactionsEntities;
    }

    public void validateTransactionParameterForNulls(TransactionsEntity transactionsEntity){
        if(transactionsEntity.getId() == null
                || transactionsEntity.getAccount() == null
                || transactionsEntity.getAmount() == null
                || transactionsEntity.getDescription() == null
//                || transactionsEntity.getCategories() == null
                || transactionsEntity.getAuthorizedDate() == null){
                LOGGER.error("TransactionEntity Parameter found null: {}", transactionsEntity.toString());
        }
    }

    private TransactionsGetRequest createRequest(String accessToken, LocalDate startDate, LocalDate endDate){
        return new TransactionsGetRequest()
                .accessToken(accessToken)
                .startDate(startDate)
                .endDate(endDate);
    }
}
